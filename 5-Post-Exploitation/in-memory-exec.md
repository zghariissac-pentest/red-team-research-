# In-memory execution

In-memory execution is the process of running payloads directly in RAM without touching disk. This reduces signature detection, avoids antivirus scanning, and minimizes forensic artifacts. It is one of the core techniques for stealthy post-exploitation operations.

## Why in-memory matters

No permanent files for antivirus to scan

No hashes, timestamps, or artifacts written to disk

EDR has limited visibility over encrypted memory regions

Execution can blend in with legitimate process behavior

Payloads can be loaded, executed, and wiped instantly

## Memory loading techniques
### Reflective dll loading

Loads a DLL from memory without using the Windows loader.

### Key points:

Manual parsing of PE headers

Resolve imports and relocations dynamically

Call the module entry point manually

No file required on disk

### Tools: Reflective DLL Injection, sRDI, Donut

Shellcode injection

Inject raw shellcode into a target process.

### Common methods:

CreateRemoteThread

NtQueueApcThread

Thread hijacking

Fiber switching

Better variants:

Indirect syscalls

RW / RX remapping

Per-page encryption

PE loading

Load a PE file (EXE or DLL) into memory without execution from disk.

### Approaches:

Manual mapping

Process hollowing

Process doppelganging

Transacted hollowing

## Execution methods
### Thread hijacking

Suspend a thread, change its instruction pointer to your shellcode, then resume.

### Benefits:

No new threads created

Less suspicious process behavior

Good for evading user-mode hooks

APC execution

Queue an asynchronous procedure call into a thread to run your shellcode.

## Advantages:

No direct thread creation API

Works with both local and remote processes

Good for stealth beacons

Syscall-based execution

Execute shellcode using syscalls only to bypass hooked APIs.

## Core ideas:

Resolve syscalls at runtime

Avoid ntdll hooks

Call kernel directly

No suspicious stack traces

Frameworks: SysWhispers3, InlineWhispers, HellsGate

Memory protection techniques
RWX avoidance

EDRs flag RWX memory regions immediately.

## Use:

RW / RX switching

Per-function decryption

Temporary RW regions only when needed

Encrypted payload storage

Keep payload encrypted inside memory and decrypt only small portions during execution.

### Benefits:

Low entropy spikes

No stable malicious patterns

Harder for scanners to analyze memory snapshots

Section misdirection

Hide payload in memory sections that resemble legitimate modules.

#### Examples:

.text-like sections

Using named shared memory objects

Embedding inside mapped DLL regions

## Stealth improvements
### Unhooking ntdll

Replace hooked API regions with clean ones from disk or manual mapping.

#### Effect:

Eliminates EDR user-mode interception

Restores original syscall stubs

ETW patching

Patch ETW providers to prevent script telemetry and process events.

AMSI bypass

Patch scanning routines or initialize script engines without AMSI.

Parent spoofing

Spawn temporary execution via trusted parent processes to reduce suspicion.

Tools

Donut / creates in-memory .NET and PE loaders

srdi / converts DLL to reflective shellcode

PEzor / packer and obfuscator for fileless payloads

Havoc Beacon / strong memory-only execution model

Mythic Atlas / Apollo agents built for in-memory operations

BOF loaders / lightweight, encrypted, in-memory execution for Cobalt/Havoc
