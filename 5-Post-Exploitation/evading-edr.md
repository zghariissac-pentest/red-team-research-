# Evading edr

Evading EDR is about avoiding telemetry, bypassing user-mode hooks, and reducing behavioral indicators that modern detection engines rely on. The goal is silent execution rather than noisy exploitation.

## Execution bypass
### Hook evasion

Use direct system calls instead of Win32 APIs to bypass user-mode hooks.

Resolve syscalls dynamically to avoid static signature detection.

Use syscall number extraction from fresh, unhooked ntdll regions.

### Unhooking

Restore clean ntdll sections from disk using manual mapping.

Patch jump stubs inserted by EDR into common APIs.

Use remote thread injection to avoid local API interception.

### DLL sideloading

Abuse vulnerable signed applications to load custom DLLs.

Prefer LOLBins like msiexec, wscript, esentutl, outdated vendor tools.

Use export forwarding to mimic legitimate library behavior.

## Memory evasion
### Reflective loading

Load payloads directly from memory without touching disk.

Avoid RWX sections; use RX + dynamic remapping.

Encrypt payload in memory and decrypt only the active region.

## Inline encryption

Use per-function decryption.

Implement on-demand memory decryption to reduce detectable entropy.

Syscall-only shellcode execution

Patchless, indirect syscalls to avoid stack traces.

Avoid CreateRemoteThread; use NtQueueApcThread or thread hijacking.

## Behavior evasion
### Parent/child spoofing

Use signed, trusted parent processes to launch payloads.

Avoid suspicious chains like powershell / msbuild / payload.

## ETW patching

Patch ETW providers in-process to suppress telemetry.

Alternatively trigger ETW “flooding” to reduce monitoring fidelity.

AMSI bypass

Patch AmsiScanBuffer.

Use COM-based execution (ScriptControl, WMI) to skip AMSI entirely.

Use PowerShell runspaces without AMSI initialization
